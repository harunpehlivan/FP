# The Pure game.

# **LEVEL 1**

```javascript
const minimum = 21;
const checkAge = age => age >= minimum;
checkAge(23); // true 
```
?[Pure or Impure Game?]
-[x] Impure
-[ ] Pure
::: My collapsible section
_Given the same inputs, always returns the same output, and has no side-effects._
const minimum = 21; // calling minimum makes it impure  
:::

***
***

```javascript
const checkAge = (age) => {
  const minimum = 21; 
  return age >= minimum;
};
checkAge(1); // false 
```
?[Pure or Impure Game?]
-[ ] Impure
-[x] Pure
::: My collapsible section
const minimum = 21; // calling minimum inside block scope make it pure
// I can also makes the minimum immutable: const immutableState = Object.freeze({ minimum: 21 });
:::

***
***

```javascript
arr = [1,2,3,4,5];
newArr = arr.map( (x) => { return x*2 }); 
```
?[Pure or Impure Game?]
-[ ] Impure
-[x] Pure
::: My collapsible section
.map() is a pure method which does NOT mutate data. 
There are no side effects using .map()
:::

***
***

```javascript
arr = [1,2,3,4,5];
newArr = arr.map( (x) => { return x*2 }); 
```
?[Pure or Impure Game?]
-[ ] Impure
-[x] Pure
::: My collapsible section
.map() is a pure method which does NOT mutate data. 
There are no side effects using .map()
:::

***
***

# **LEVEL 2**

```javascript
const arr = [1,2,3,4,5];

arr.slice(0,3);
arr.slice(0,3);
arr.slice(0,3);
```
?[Pure or Impure Game?]
-[ ] Impure
-[x] Pure
::: My collapsible section
arr.slice(0,3); // [1,2,3]
arr.slice(0,3); // [1,2,3]
arr.slice(0,3); // [1,2,3]

slice don't mutate
:::

***
***

```javascript
const arr = [1,2,3,4,5];

arr.splice(0,3);
arr.splice(0,3); 
arr.splice(0,3); 
```
?[Pure or Impure Game?]
-[x] Impure
-[ ] Pure
::: My collapsible section
arr.splice(0,3); // [1,2,3]
arr.splice(0,3); // [4,5]
arr.splice(0,3); // []

slice mutate: .splice() and .slice() 
They are two functions that do the exact same thing, mutation is where the difference is
:::

***
***


```javascript
var arr = [1,2,3,4,5];

[...arr].reverse()
[...arr].sort()

```
?[Pure or Impure Game?]
-[ ] Impure
-[x] Pure
::: My collapsible section
var arr = [1,2,3,4,5];
arr.reverse(); // [5, 4, 3, 2, 1] reverse mutate here
arr.reverse(); // [1, 2, 3, 4, 5] and here

.reverse() and .sort()
We can use the spread operator to avoid mutation
:::

***
***

# **LEVEL 3**

```javascript
const addWheels = (obj, num) => Object.assign({}, obj, {wheels: num});
const noWheelTruck = {type: 'truck'};
const fourWheelTruck = addWheels(noWheelTruck, 4);
console.log(noWheelTruck);
```
?[Pure or Impure Game?]
-[ ] Impure
-[x] Pure
::: My collapsible section
const addWheels = (obj, num) => Object.assign({}, obj, {wheels: num}); //  pure ES5 way
const noWheelTruck = {type: 'truck'};
const fourWheelTruck = addWheels(noWheelTruck, 4); // {type: 'truck', wheels: 4}
console.log(noWheelTruck); // {type: 'truck'} original object unchanged
:::

***
***

```javascript
const addWheelsImpure = (obj, num) => {obj['wheels'] = num};
const noWheelCar = {type: 'car'};
const fourWheelCar = addWheelsImpure(noWheelCar, 4);
console.log(noWheelCar);
```
?[Pure or Impure Game?]
-[X] Impure
-[ ] Pure
::: My collapsible section
const addWheelsImpure = (obj, num) => {obj['wheels'] = num};
const noWheelCar = {type: 'car'};
const fourWheelCar = addWheelsImpure(noWheelCar, 4); //=>{type: 'car', wheels: 4}
console.log(noWheelCar) //{ type: 'car', wheels: 4 } MUTATED!
:::

***
***

# **LEVEL 4**

***
***

```javascript
function returnZeroFunc() {
    function fZero() {
        console.log('Launching nuclear missiles');
        // Code to launch nuclear missiles goes here
        return 0;
    }
    return fZero;
}
```
?[Pure or Impure Game?]
-[ ] Impure
-[x] Pure
::: My collapsible section
"A side effect isn’t a side effect until it actually happens":
 pure: Our returnZeroFunc() function does nothing other than return the same function, every time.
 
We wrapped fZero() inside another function that just returned it
This function wrapping thing is a legitimate strategy. 
We can keep hiding behind functions as long as we want. 
And as long as we never actually call any of these functions, they’re all theoretically pure. 
Wrapping everything in a function lets us control those effects with precision. We decide exactly when those side effects happen. 

:::

***
***

```javascript
function fZero() {
    console.log('IMPURE');
    return 0;
}
function fIncrement(f) {
    return f() + 1;
}
```
?[Pure or Impure Game?]
-[x] Impure
-[ ] Pure
::: My collapsible section

:::

***
***

```javascript
function fZero() {
    console.log('IMPURE');
    return 0;
}
function fIncrement(f) {
    return () => f() + 1;
}
fIncrement(fZero);
```
?[Pure or Impure Game?]
-[ ] Impure
-[x] Pure
::: My collapsible section
fIncrement(fZero);  // () =>
:::

***
***





# TECHIO> annotate
# Usage

```bash
TECHIO> annotate --file <FILENAME> --position <LINE[:COLUMN]> [OPTIONS] <MESSAGE>
```

# Description
Annotate the client code editor with margin marker and an associated message.


# Options

`-f, --file <FILENAME>` FILENAME is used to select the code editor associated with the displayed annotation. If a client editor filename is contained in the command filename, this editor is selected. If the FILENAME does not match with a client editor filename, the annotation is not displayed.


`-p, --position <LINE[:COLUMN]>` LINE represents the line of the marker. A COLUMN value can be appended to give more details about the precise position of the annotation. LINE and COLUMN are integer values.


`-t, --type <TYPE>` TYPE of the annotation. Valid values include: info, warning, and error. The default value is error.


`-c, --channel <CHANNEL>` The annotation information can also be optionally printed on a CHANNEL.

# Examples
Display a warning annotation on the line 3 of a main.js editor file with the associated message: warn: ';' not found.

```bash
TECHIO> annotate --type "warning" --file "a.js" --position 3 warn: ';' not found
```

Display an error annotation on the line 4 of a Main.java editor file with the following message: error: ';' expected at end of line. It also prints the message on a compilation channel with the name of the file, the line number, and the column.

```bash
TECHIO> annotate --channel "compilation" --file "Main.java" --position 4:8 error: ';' expected at end of line
```

