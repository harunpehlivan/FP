# The Pure (or Impure) game.

![Alt text](https://github.com/leolanese/FP/blob/master/nintendopressreleasead.jpg)
![Alt text](https://github.com/leolanese/FP/blob/master/nintendopressreleasead.jpg "The Stormtroopocat")


* You need to answer if the next functions are **Pure** Or **Impure**
* The question are in increasing level of difficulty. 

> ** Level 1 **
>> ** Level 2 ** 
>>> ** Level 3 **
>>>> ** Level 4 ** 



# **LEVEL 1**

```javascript
const minimum = 21;
const checkAge = age => age >= minimum;
checkAge(23); // true 
```
?[Pure or Impure Game?]
-[x] Impure
-[ ] Pure
::: but why?
_Given the same inputs, always returns the same output, and has no side-effects._
const minimum = 21; // calling minimum makes it impure  
:::

***
***

```javascript
const checkAge = (age) => {
  const minimum = 21; 
  return age >= minimum;
};
checkAge(1); // false 
```
?[Pure or Impure Game?]
-[ ] Impure
-[x] Pure
::: but why?
const minimum = 21; // calling minimum inside block scope make it pure
// I can also makes the minimum immutable: const immutableState = Object.freeze({ minimum: 21 });
:::

***
***

```javascript
arr = [1,2,3,4,5];
newArr = arr.map( (x) => { return x*2 }); 
```
?[Pure or Impure Game?]
-[ ] Impure
-[x] Pure
::: but why?
.map() is a pure method which does NOT mutate data. 
There are no side effects using .map()
:::

***
***

```javascript
arr = [1,2,3,4,5];
newArr = arr.map( (x) => { return x*2 }); 
```
?[Pure or Impure Game?]
-[ ] Impure
-[x] Pure
::: but why?
.map() is a pure method which does NOT mutate data. 
There are no side effects using .map()
:::

***
***

# **LEVEL 2**

```javascript
const arr = [1,2,3,4,5];

arr.slice(0,3);
arr.slice(0,3);
arr.slice(0,3);
```
?[Pure or Impure Game?]
-[ ] Impure
-[x] Pure
::: but why?
arr.slice(0,3); // [1,2,3]
arr.slice(0,3); // [1,2,3]
arr.slice(0,3); // [1,2,3]

slice don't mutate
:::

***
***

```javascript
const arr = [1,2,3,4,5];

arr.splice(0,3);
arr.splice(0,3); 
arr.splice(0,3); 
```
?[Pure or Impure Game?]
-[x] Impure
-[ ] Pure
::: but why?
arr.splice(0,3); // [1,2,3]
arr.splice(0,3); // [4,5]
arr.splice(0,3); // []

slice mutate: .splice() and .slice() 
They are two functions that do the exact same thing, mutation is where the difference is
:::

***
***


```javascript
var arr = [1,2,3,4,5];

[...arr].reverse()
[...arr].sort()

```
?[Pure or Impure Game?]
-[ ] Impure
-[x] Pure
::: but why?
var arr = [1,2,3,4,5];
arr.reverse(); // [5, 4, 3, 2, 1] reverse mutate here
arr.reverse(); // [1, 2, 3, 4, 5] and here

.reverse() and .sort()
We can use the spread operator to avoid mutation
:::

***
***

# **LEVEL 3**

```javascript
const addWheels = (obj, num) => Object.assign({}, obj, {wheels: num});
const noWheelTruck = {type: 'truck'};
const fourWheelTruck = addWheels(noWheelTruck, 4);
console.log(noWheelTruck);
```
?[Pure or Impure Game?]
-[ ] Impure
-[x] Pure
::: but why?
const addWheels = (obj, num) => Object.assign({}, obj, {wheels: num}); //  pure ES5 way
const noWheelTruck = {type: 'truck'};
const fourWheelTruck = addWheels(noWheelTruck, 4); // {type: 'truck', wheels: 4}
console.log(noWheelTruck); // {type: 'truck'} original object unchanged
:::

***
***

```javascript
const addWheelsImpure = (obj, num) => {obj['wheels'] = num};
const noWheelCar = {type: 'car'};
const fourWheelCar = addWheelsImpure(noWheelCar, 4);
console.log(noWheelCar);
```
?[Pure or Impure Game?]
-[X] Impure
-[ ] Pure
::: but why?
const addWheelsImpure = (obj, num) => {obj['wheels'] = num};
const noWheelCar = {type: 'car'};
const fourWheelCar = addWheelsImpure(noWheelCar, 4); //=>{type: 'car', wheels: 4}
console.log(noWheelCar) //{ type: 'car', wheels: 4 } MUTATED!
:::

***
***

# **LEVEL 4**

***
***

```javascript
function returnZeroFunc() {
    function fZero() {
        console.log('Launching nuclear missiles');
        // Code to launch nuclear missiles goes here
        return 0;
    }
    return fZero;
}
```
?[Pure or Impure Game?]
-[ ] Impure
-[x] Pure
::: but why?
"A side effect isn’t a side effect until it actually happens":
 pure: Our returnZeroFunc() function does nothing other than return the same function, every time.
 
We wrapped fZero() inside another function that just returned it
This function wrapping thing is a legitimate strategy. 
We can keep hiding behind functions as long as we want. 
And as long as we never actually call any of these functions, they’re all theoretically pure. 
Wrapping everything in a function lets us control those effects with precision. We decide exactly when those side effects happen. 

:::

***
***

```javascript
function fZero() {
    console.log('IMPURE');
    return 0;
}
function fIncrement(f) {
    return f() + 1;
}
```
?[Pure or Impure Game?]
-[x] Impure
-[ ] Pure
::: but why?

:::

***
***

```javascript
function fZero() {
    console.log('IMPURE');
    return 0;
}
function fIncrement(f) {
    return () => f() + 1;
}
fIncrement(fZero);
```
?[Pure or Impure Game?]
-[ ] Impure
-[x] Pure
::: but why?
fIncrement(fZero);  // () =>
:::

***
***


