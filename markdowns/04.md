# The Pure (or Impure) game.


* You need to answer if the next functions are **Pure** Or **Impure**
* The question are in increasing level of difficulty. 

> ** Level 1 **
>> ** Level 2 ** 
>>> ** Level 3 **
>>>> ** Level 4 ** 


![Impure? NO thanks!](https://raw.githubusercontent.com/leolanese/FP/master/joke.jpg)


# **LEVEL 1**

```javascript runnable
let minimum = 21;
const checkAge = age => age >= minimum;
checkAge(23); // true
```
?[Pure or Impure Game?]
-[x] Impure
-[ ] Pure
::: but why?
Impure!

Impure function A side-effect here is a change of system state: **it is no completely independent of outside state**, due to this external call to non-constants we break the rules:
- _Given the same inputs, always returns the same output_ 
- _No side-effects_
 
**FP avoids shared state, instead relying on immutable data structures and pure calculations.**

```
const minimum = 21; // the calling to minimum makes it impure  
```

:::

***
***

```javascript runnable
const checkAge = (age) => {
  const minimum = 21; 
  return age >= minimum;
};
checkAge(1); // false 
```
?[Pure or Impure Game?]
-[ ] Impure
-[x] Pure
::: but why?
Pure!

const minimum = 21; // calling minimum inside block scope make it pure

We can also makes the minimum immutable: 

```
const immutableState = Object.freeze({ minimum: 21 });
```

:::

***
***

```javascript runnable
let arr = [1,2,3,4,5];
newArr = arr.map( (x) => { return x*2 }); 
```
?[Pure or Impure Game?]
-[ ] Impure
-[x] Pure
::: but why?
Pure!

- .map() is a pure method which does NOT mutate data. 
- There are no side effects using .map()

:::

***
***

# **LEVEL 2**

```javascript runnable
const arr = [1,2,3,4,5];

console.log( arr.slice(0,3) );
console.log( arr.slice(0,3) );
console.log( arr.slice(0,3) );
```
?[Pure or Impure Game?]
-[ ] Impure
-[x] Pure
::: but why?
Pure! 
slice method don't mutate

```
console.log( arr.slice(0,3) ); // [1,2,3]
console.log( arr.slice(0,3) ); // [1,2,3]
console.log( arr.slice(0,3) ); // [1,2,3]
```

:::

***
***

```javascript
const arr = [1,2,3,4,5];

console.log( arr.splice(0,3) );
console.log( arr.splice(0,3) );
console.log( arr.splice(0,3) );
```
?[Pure or Impure Game?]
-[x] Impure
-[ ] Pure
::: but why?
Impure! 
slice method mutate

```
arr.splice(0,3); // [1,2,3]
arr.splice(0,3); // [4,5]
arr.splice(0,3); // []
```

Tip:
.splice() and .slice() 
They are two functions that do the **exactly same thing**, but **mutation is where the difference is***

:::

***
***

```javascript runnable
const arr = [1,2,3,4,5];
console.log( [...arr].reverse() );
console.log( [...arr].sort() );

```
?[Pure or Impure Game?]
-[ ] Impure
-[x] Pure
::: but why?

const arr = [1,2,3,4,5];
arr.reverse(); // [5, 4, 3, 2, 1] reverse mutate here
arr.sort();    // [1, 2, 3, 4, 5] and sort here

[...arr].reverse(); // [5, 4, 3, 2, 1] but **spread operator** we can avoid mutation creating a new object
[...arr].sort(); // [1, 2, 3, 4, 5] but **spread operator** we can avoid mutation creating a new object

.reverse() and .sort() both mutate, but using the spread operator we can avoid mutation
:::

***
***

# **LEVEL 3**

```javascript runnable
const addWheels = (obj, num) => Object.assign({}, obj, {wheels: num});
const noWheelTruck = {type: 'truck'};
const fourWheelTruck = addWheels(noWheelTruck, 4);
console.log(noWheelTruck);
```
?[Pure or Impure Game?]
-[ ] Impure
-[x] Pure
::: but why?

const addWheels = (obj, num) => Object.assign({}, obj, {wheels: num}); //  pure ES5 way
const noWheelTruck = {type: 'truck'};
const fourWheelTruck = addWheels(noWheelTruck, 4); // {type: 'truck', wheels: 4}
console.log(noWheelTruck); // {type: 'truck'} original object unchanged

:::

***
***

```javascript
const addWheelsImpure = (obj, num) => {obj['wheels'] = num};
const noWheelCar = {type: 'car'};
const fourWheelCar = addWheelsImpure(noWheelCar, 4);
console.log(noWheelCar);
```
?[Pure or Impure Game?]
-[X] Impure
-[ ] Pure
::: but why?
const addWheelsImpure = (obj, num) => {obj['wheels'] = num};
const noWheelCar = {type: 'car'};
const fourWheelCar = addWheelsImpure(noWheelCar, 4); //=>{type: 'car', wheels: 4}
console.log(noWheelCar) //{ type: 'car', wheels: 4 } MUTATED!
:::

***
***

# **LEVEL 4**

***
***

```javascript
function returnZeroFunc() {
    function fZero() {
        console.log('Launching nuclear missiles');
        // Code to launch nuclear missiles goes here
        return 0;
    }
    return fZero;
}
```
?[Pure or Impure Game?]
-[ ] Impure
-[x] Pure
::: but why?
"A side effect isn’t a side effect until it actually happens":
 pure: Our returnZeroFunc() function does nothing other than return the same function, every time.
 
We wrapped fZero() inside another function that just returned it
This function wrapping thing is a legitimate strategy. 
We can keep hiding behind functions as long as we want. 
And as long as we never actually call any of these functions, they’re all theoretically pure. 
Wrapping everything in a function lets us control those effects with precision. We decide exactly when those side effects happen. 

:::

***
***

```javascript
function fZero() {
    console.log('IMPURE');
    return 0;
}
function fIncrement(f) {
    return f() + 1;
}
```
?[Pure or Impure Game?]
-[x] Impure
-[ ] Pure
::: but why?

:::

***
***

```javascript
function fZero() {
    console.log('IMPURE');
    return 0;
}
function fIncrement(f) {
    return () => f() + 1;
}
fIncrement(fZero);
```
?[Pure or Impure Game?]
-[ ] Impure
-[x] Pure
::: but why?
fIncrement(fZero);  // () =>
:::

***
***


