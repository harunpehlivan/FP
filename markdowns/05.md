> "OOP vs FP: Don't be an FP programmer, don't be an OOP programmer... BE A BETTER PROGRAMMER."
> ~ @fernando_cejas

# Thinking Functionally, the mindset game. 

## So, How can I use it?

### **Separate the pure from the impure**
If a function is impure, if posible, split it and simple as creating two functions

***

### **Dont change objects in functions**

```javascript runnable
// MUTATED
function save(object){
    object.saved = true; // don’t
    return object;
}
```

```javascript runnable
// PURE
// Write functions that return altered copies instead of changing properties of the given object.
function save(object){
    let newObject = object.clone(); // clone :)
    newObject.saved = true;
    return newObject;
}
```

***

### *Expressions instead of Statements (don't use if, use shorthand if)

```javascript runnable
// Statement
const getSalutation = function(hour) {
    var salutation; // temp value
    if (hour < 12) {
      salutation = "Good Morning";
    }
    else {
      salutation = "Good Afternoon"
    }
    return salutation; // mutated value
  } 
```

```javascript runnable
// Expression
const getSalutation = (hour) => hour < 12 ? "Good Morning" : "Good Afternoon";
console.log(getSalutation(10)); // Good Morning
```

***

### **Use Arrow Functions (fat arrow)**

[ES6 Arrow functions](https://github.com/leolanese/ES6_workshop/blob/master/2.2-Arrow%20functions.md") create a concise expression that encapsulates a small piece of functionality. 
Additionally, arrows retain the scope of the caller inside the function eliminating the need of self = this.

```javascript runnable
// old style
var multiply = function(x,y) {
  return x * y;
}
console.log(multiply(2,10)); //20
```

```javascript runnable
// ES6 new style
const multiply = (x, y) => x * y;
console.log(multiply(2,10)); //20
```

***

### **Avoid loops and iteration**
<p>A loop is an imperative control structure that is hard to reuse and difficult to plug in to other operations. 
We can use Recursion,.map(), .reduce(), .filter(), etc </p>

```javascript runnable
// take an array of Object just get an specific key(s)
// Using old imperative programming
var ao = [{
        "name": "Zak",
        "age": 25
    },{
        "name": "Adel",
        "age": 38
    },{
        "name": "Yori",
        "age": 28
    }
];
for (var i = 0, arr = []; i < ao.length; i++) {
  arr.push(ao[i].name); // mutation sucks :(
};  
consol.log(arr); // ["Zak", "Adel", "Yori"]

```

```javascript runnable
// better: using FP, avoid loops
const x = (x) => x.name; // minimizing moving parts
[{
        "name": "Zak",
        "age": 25
    },{
        "name": "Adel",
        "age": 38
    },{
        "name": "Yori",
        "age": 28
    }
].map(x); // ["Zak", "Adel", "Yori"]

```

Tip:
Think about results over steps. Next time you are about to iterate something, stop, and think about: 
"How this can look if I don't iterate this?"
[Loops & Iteration](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration "Loops & Iteration")

***

### **Use array manipulation functions & Avoid mutator methods**


**DO NOT** use the mutator methods, these methods modify the array:
.push(), .copyWith(), .fill(), .pop(), .reverse(), .shift(), .sort(), .splice(), .unshift()

**Better USE** non-mutating methods (Accessor methods, Iteration methods ):
.concat(), .join(), .slice(), .toString(), .reduce(), .reduceRight(), etc.

Full list:
[Mutator_method](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype#Mutator_methods Mutator_method)

***

### **Use Higher-order-Function (HoF) when possible**

```javascript runnable
let jsonData = [
  { id: 1, name: "Soda", price: 2.40, cost: 1.04, size: "4cl", },
  { id: 2, name: "Beer", price: 6.00, cost: 2.45, size: "8cl" },
  { id: 3, name: "Margarita", price: 10, cost: 4.45, size: "12cl" }
];
let objNoProperties = jsonData
                      .map(x => ({name: x.name, price: x.price}));
console.log(JSON.stringify(objNoProperties)); 
// [{"name":"Soda","price":2.4},{"name":"Beer","price":6},{"name":"Margarita","price":10}]                       
```

```javascript runnable
// ...x (spread operator) ensures that we copy the complete object and its properties, while only modifying the price value. 
const objAndProperties = objNoProperties
                        .map(x => ({...x, price: (x.price / 2).toFixed(1) }));

console.log(JSON.stringify(objAndProperties));
// "[{"name":"Soda","price":"1.2"},{"name":"Beer","price":"3.0"},{"name":"Margarita","price":"5.0"}]"
```

***

### **Use Method Chaining**
Method chains allow a series of functions to operate in succession to reach a final result. Method chains allow 
function composition similar to a pipeline.

```javascript runnable
let cart = [{name: "Drink", price: 3.12}, 
            {name: "Steak", price: 45.15}, 
            { name: "Drink", price: 11.01}];
let drinkTotal = cart.filter(x=> x.name === "Drink")
                     .map(x=> x.price)
                     .reduce((t,v) => t +=v)
                     .toFixed(2); 
console.log(Total Drink Cost $${drinkTotal}); // Total Drink Cost $14.13
```

***

### **Use pipelines**
A pipeline allows for easy function composition when performing multiple operations on a variable. Since 
JavaScript lacks a Pipeline operator, a design pattern can be used to accomplish the task.

```
const pipe = functions => data => {
  return functions.reduce(
    (value, func) => func(value),
    data
  );
};

let cart = [3.12, 45.15, 11.01];
const addSalesTax = (total, taxRate) => (total * taxRate) + total;

const tally = orders => pipe([
  x => x.reduce((total, val) => total + val), // sum the order
  x => addSalesTax(x, 0.09),
  x => `Order Total = ${x.toFixed(2)}` // convert to text
])(orders); // Order Total = 64.62
```

***


### **Dependency injection**
Dependency injection works by moving the impure parts of the code out of the function. 
So you have to pass them in as parameters. 

```javascript runnable
const d = {toISOString: () => '1865-11-26T16:00:00.000Z'};
// impure
function logSomething(foo) {
    const dt = (new Date()).toISOString(); // Date is impure
    console.log(`${dt}: ${foo}`); // IO log is impure
    return foo;
}

logSomething('Date is impure! & IO log is impure :(');
```

```javascript runnable
// make it pure using dependency injection:
// take any impurities and make them a function parameter now we'll have 3 params:
function logSomething(d, cnsl, foo) {
    const dt = d.toISOString();
    cnsl.log(`${dt}: ${foo}`);
    return foo;
}

// then we call it with the impure parts
const foo = "make it pure using dependency injection!"
const d = new Date();
logSomething(d, console, foo);
// so yes! If you call it with those same parameters, it will return the same thing every single time.
// and no external contact = pure.
// That's the trick :) 
```

***

<p>sum all values of the Array</p>
```javascript runnable
const values = [1, 2, 3, 3, 5];
let sum = 0;
values.forEach( v => { sum += v; } ); // forEach() is still a loop
console.log( sum ); // 14
```

```javascript runnable
const values = [1, 2, 3, 3, 5];
const sum = values.reduce( (accumulator, v) => {
    const result = accumulator + v;
    return result;
}, 0 );
console.log( sum ); // 14
```

***

<p>Get cats younger than 7 months</p>
```javascript runnable
const cats = [
  { name: 'Mojo',    months: 84 },
  { name: 'Mao-Mao', months: 34 },
  { name: 'Waffles', months: 4 },
  { name: 'Pickles', months: 6 }
]
var kittens = []
// old `for loop` :(
for (let i = 0; i < cats.length; i++) {
  if (cats[i].months < 7) {
    kittens.push(cats[i].name)
  }
}
console.log(kittens); // ["Waffles", "Pickles"]
```

```javascript runnable
// better do :)
const isKitten = cat => cat.months < 7; // check reusability moving parts! 
const getName = cat => cat.name; // sexy code :)

const getKittenNames = cats => cats
      .filter(isKitten)
      .map(getName)
const kittens = getKittenNames(cats)
console.log(kittens); // ["Waffles", "Pickles"]
```

***

### **Lazy functions**
Controlling the side-effect: A side effect isn’t a side effect until it actually happens.

```javascript runnable
// fZero() is impure
function fZero() { 
    console.log('IMPURE'); // IO log = Impure
    return 0;
}
```

```javascript runnable
// NOW returnZeroFunc() is pure, the function does nothing other than return the same fZero function, every time.
function returnZeroFunc() {
    function fZero() {  // we wrapped fZero() inside another function that just returned it right?
        console.log('IMPURE');
        return 0;
    }
    return fZero;
}
// This function wrapping thing is a legitimate strategy.
// We can keep hiding behind functions as long as we want. Oh yes!
// And as long as we never actually call any of these functions, they’re all theoretically pure. 
// So, we control the side-effect:
// Wrapping everything in a function lets us control those effects with precision. 
// We decide exactly when those side effects happen. 
const zeroFunc1 = returnZeroFunc(); // pure
```

***

### **Freeze all objects and arrays (since modifying an existing object or array would be a stateful expression)**

***

### **Avoid few impure methods**
Date (Date.now), Math.random (since it always produces a new value no matter what the inputs are), console.log(), this, global
variables, exceptions thrown, etc. In fact, because JavaScript passes object references around, every function that takes an object or array is potentially subject to impurity. 

*** 

### ****




