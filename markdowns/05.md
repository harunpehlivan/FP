> "OOP vs FP: Don't be an FP programmer, don't be an OOP programmer... BE A BETTER PROGRAMMER."
> ~ @fernando_cejas

# Thinking Functionally, the mindset game. 

## So, How can I use it?

### * Create functions with parameters parameter

***

### * Dependency injection
```javascript runnable
// impure
function logSomething(foo) {
    const dt = (new Date()).toIsoString(); // Date is impure
    console.log(`${dt}: ${foo}`); // IO log is impure
    return foo;
}

logSomething()
```

```javascript runnable
// make it pure using dependency injection:
// take any impurities and make them a function parameter now we'll have 3 params:
function logSomething(d, cnsl, foo) {
    const dt = d.toIsoString();
    cnsl.log(`${dt}: ${foo}`);
    return foo;
}

// then we call it with the impure parts
const foo = "make it pure using dependency injection!"
const d = new Date();
logSomething(d, console, foo);
```



### * Avoid for loops or while statements
<p>A loop is an imperative control structure that is hard to reuse and difficult to plug in to other operations. We can use Recursion instead or use HoF .map(), .reduce(), .filter(), etc </p>

<p>Avoid while</p>

```javascript runnable
/*
0 1
1 2
3 3
6 4
10 5
15 6
21 7
28 8
36 9
45 10
55
*/ 
var total = 0, count = 1;
while (count <= 10) {
  total += count;
  count += 1;
}
console.log(total); // 55
```

```javascript runnable
// using FP
console.log(sum(range(1, 10))); // 55
```

<p>Array of Object just get an specific key(s)</p>

```javascript runnable
// Using imperative programming
var ao = [{
        "name": "Zak",
        "age": 25
    },{
        "name": "Adel",
        "age": 38
    },{
        "name": "Yori",
        "age": 28
    }
];
for (var i = 0, arr = []; i < ao.length; i++) {
  arr.push(ao[i].name); // mutation sucks :(
};  
consol.log(arr); // ["Zak", "Adel", "Yori"]

```

```javascript runnable
// better: using FP, avoid loops
[{
        "name": "Zak",
        "age": 25
    },{
        "name": "Adel",
        "age": 38
    },{
        "name": "Yori",
        "age": 28
    }
].map((x)=> x.name); // ["Zak", "Adel", "Yori"]

```

***

<p>sum all values of the Array</p>
```javascript runnable
const values = [1, 2, 3, 3, 5];
let sum = 0;
values.forEach( v => { sum += v; } ); // forEach() is still a loop
console.log( sum ); // 14
```

```javascript runnable
const values = [1, 2, 3, 3, 5];
const sum = values.reduce( (accumulator, v) => {
    const result = accumulator + v;
    return result;
}, 0 );
console.log( sum ); // 14
```

***

<p>Get cats younger than 7 months</p>
```javascript runnable
const cats = [
  { name: 'Mojo',    months: 84 },
  { name: 'Mao-Mao', months: 34 },
  { name: 'Waffles', months: 4 },
  { name: 'Pickles', months: 6 }
]
var kittens = []
// old `for loop` :(
for (let i = 0; i < cats.length; i++) {
  if (cats[i].months < 7) {
    kittens.push(cats[i].name)
  }
}
console.log(kittens); // ["Waffles", "Pickles"]
```

```javascript runnable
// better do :)
const isKitten = cat => cat.months < 7; // check reusability moving parts! 
const getName = cat => cat.name; // sexy code :)

const getKittenNames = cats => cats
      .filter(isKitten)
      .map(getName)
const kittens = getKittenNames(cats)
console.log(kittens); // ["Waffles", "Pickles"]
```

***

### * Use Higher-order-Function (HoF) when possible

```javascript runnable
let jsonData = [
  { id: 1, name: "Soda", price: 2.40, cost: 1.04, size: "4cl", },
  { id: 2, name: "Beer", price: 6.00, cost: 2.45, size: "8cl" },
  { id: 3, name: "Margarita", price: 10, cost: 4.45, size: "12cl" }
];
let objNoProperties = jsonData
                      .map(x => ({name: x.name, price: x.price}));
console.log(JSON.stringify(objNoProperties)); 
// [{"name":"Soda","price":2.4},{"name":"Beer","price":6},{"name":"Margarita","price":10}]                       
```

```javascript runnable
// ...x (spread operator) ensures that we copy the complete object and its properties, while only modifying the price value. 
const objAndProperties = objNoProperties
                        .map(x => ({...x, price: (x.price / 2).toFixed(1) }));

console.log(JSON.stringify(objAndProperties));
// "[{"name":"Soda","price":"1.2"},{"name":"Beer","price":"3.0"},{"name":"Margarita","price":"5.0"}]"
```

***

### Avoid mutator methods

DO NOT use the mutator methods, these methods modify the array:
.copyWith(), .fill(), .pop(), .push(), .reverse(), .shift(), .sort(), .splice(), .unshift()

Better USE non-mutating methods (Accessor methods, Iteration methods ):
.concat(), .join(), .slice(), .toString(), .reduce(), .reduceRight(), etc.

Full list:
[Mutator_method](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype#Mutator_methods Mutator_method)



### Dont change objects in functions

```javascript runnable
// MUTATED
function save(object){
    object.saved = true; // donâ€™t
    return object;
}
```

```javascript runnable
// pure
// Write functions that return altered copies instead of changing properties of the given object.
function save(object){
    let newObject = object.clone(); // clone :)
    newObject.saved = true;
    return newObject;
}
```

### *separate the pure from the impure
If a function is impure, if posible, split it and simple as creating two functions

### *Avoid long functions

### *Freeze all objects and arrays (since modifying an existing object or array would be a stateful expression)

### *Avoid few impure methods: 
Date (Date.now), Math.random (since it always produces a new value no matter what the inputs are), console.log(), this, global
variables, exceptions thrown, etc. In fact, because JavaScript passes object references around, every function that takes an object or array is potentially subject to impurity. 

### *Expressions instead of Statements (don't use if, use shorthand if)

```javascript runnable
// Statement
const getSalutation = function(hour) {
    var salutation; // temp value
    if (hour < 12) {
      salutation = "Good Morning";
    }
    else {
      salutation = "Good Afternoon"
    }
    return salutation; // mutated value
  } 
```

```javascript runnable
// Expression
const getSalutation = (hour) => hour < 12 ? "Good Morning" : "Good Afternoon";
console.log(getSalutation(10)); // Good Morning


