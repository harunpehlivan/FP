# Functional Programming Definition

> "Functional programming is a [**'declarative'**](#l-1) [**'paradigm'**](#l-2) of building software by [**'composing pure functions'**](#l-3), avoiding [**'shared state'**](#l-4), [**'mutable data'**](#l-5) and [**'side-effects'**](#l-6). Placing the mayor emphasis on the use of functions; [**'abstracting control flows and operations on data with these functions and threaten them as building blocks'**](#l-7) by relying on [**'JS first-class'**](#l-8) and [**'higher-order functions'**](#l-9) to improve the modularity, [**predictability**](#l-10) and reusability of your code.

## So, FP essencially boils down to:
- Program everyting with functions (a "function flow" takes an input and gives an output)
- Avoid shared mutable state & side-effects (use pure functions)
- FP is about pulling programs apart and reassembling them from the same parts, abstracted behind function boundaries.

<a name="l-1"></a>
## **"declarative"**
<p>FP is a declarative paradigm software development style, like IP or OOP, thats keeps 'functions' and 'data' separate
</p>

<a name="l-2"></a>
## **"paradigm"**
<p>In simple terms, it is a way of thinking about software construction, based on some development style that follow principles.
</p>

<a name="l-3"></a>
## **"composing pure functions"**
<p>
Composition means that we attach multiple functions together, in a pipe, where the return value
of the first function becomes the input for the next function:

Function composition is the process of combining two or more functions in order to produce a new function.
Simply put, a composition of functions `f` . `g` (the dot means "composed with") can be defined as `f(g(x))`
(evaluates inside out, right to left = x, g and f) 

If you want to compose two functions you are forced to write your own compose function or use the already 
available ones in libraries such as Lodash and Ramda, also R provides pipe and composition.
</p>

### Function Composition 
#### Compose and Pipe:
<p>
Composition f(g(h(x))) and Pipe are function composition, what is change is the order:
Composition: Inside out, Pipe: Outside in.
</p>


```javascript
// using compose on TS
function f() {
    console.log("f(): evaluated");
    return function (target, propertyKey: string, descriptor: PropertyDescriptor) {
        console.log("f(): called");
    }
}
function g() {
    console.log("g(): evaluated");
    return function (target, propertyKey: string, descriptor: PropertyDescriptor) {
        console.log("g(): called");
    }
}
function h() { 
    console.log("h(): evaluated");
    return function (target, propertyKey: string, descriptor: PropertyDescriptor) {
        console.log("h(): called");
    }
}
class C { // some as: f(g(h()))
    @h()
    @f()
    @g()
}
// h(): evaluated
// f(): evaluated
// g(): evaluated
// g(): called
// f(): called
// h(): called
```
<a href="https://jsfiddle.net/leolanese/mwcauz9n/">Execure TS code (JSfiddle)</p>

<a name="l-4"></a>
## **"shared state"**

> FP avoids shared state, instead relying on immutable data structures and pure calculations.

<p>
Shared state is any variable, object, or memory space that exists in a "shared scope", or as the property of an object being passed between scopes. 
</p>

### Problems:
+ Change order:
 - The problem with shared state is that in order to understand the effects of a function, you have to know the entire history of every shared variable that the function uses or affects.
 - Cascade of failures because functions which act on shared state are "timing dependent".
+ Race-condition:
 - A common bug associated to 'share state'is 'race-condition'

@[With shared state, the order in which function calls are made changes the result of the function calls]({ "stubs": ["pure/order1.js"], "command": "node pure/order1.js" })
@[This example is exactly equivalent to the above, except the order of the function calls is reversed]({ "stubs": ["pure/order2.js"], "command": "node pure/order2.js" })
@[Better avoid shared state, the timing and order of function calls don’t change the result of calling the function.]({ "stubs": ["pure/betterOrder.js"], "command": "node pure/betterOrder.js" })


<a name="l-5"></a>
## **"mutable data"** 
<p>An mutable object is any object which can be modified after it's created.</p>

### **"immutable"**
<p>
An immutable value or object cannot be changed, so every update creates new value, leaving the old one untouched.

For example, if your application state is immutable, you can save all the states objects in a single store to
 easily implement undo/redo functionality
</p>

### **"pure function"**
A pure function is a function which:
- Given the same input, always return the same output
- Has no side-effects (immutable)


 > @ngrx/store have:
 > Reducers: pure + inmutable
 > @effect: NOT pure + inmutable


```javascript runnable
// pure
function add2 (x){
  return x + 2;
}
```
```javascript runnable
// not pure
// impure: because it reads/modifies an external variable, counter, which isn’t local to the function’s scope.
const y = 2;
function adder (x){
  return x + y;
}
```

***

<a name="l-6"></a>
## **"side-effects"** 

> Mutating data can cause unintended side-effects.

> A side effect is a change of system state or observable interaction with the outside world that occurs during the calculation of a result.

### Side effects may include, but are not limited to
- Anything that rely on current time, it is impure.
- Anything that rely on random number
- Changing the file system
- Inserting a record into a database
- Making an http call
- Querying the DOM
- Accessing system state
- I/O interaction (user intput, disk access, network access, printing to the screen) is impure throws


```javascript  runnable
// impure function due to use of external non-constants
// The impure function indirectly depends on x
// If you were to change x, then addx would output a different value for the same inputs.
let x = 10
const addx = (a) => a + x
```

```javascript  runnable
// also impure due to side-effect
const setx = (v) => x = v 
```


<a name="l-7"></a>
## **"abstracting control flows and operations on data with these functions and threaten them as building blocks"**
![Minimizing moving parts](https://raw.githubusercontent.com/leolanese/FP/master/M-feathers.PNG)

<p>
Abstractions **hide details** (abstract me of the detail) and give us the ability to talk about problems at a higher (or more abstract) level.
</p>

```javascript  runnable
// calculate squares
const array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

// style using loop 
let arraySquares = [];
for(let i = 0; i < array.length; i++) {
    arraySquares[i] = Math.pow(array[i], 2);
}
console.log(arraySquares); // [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

// style no loop
array.map(x => Math.pow(x, 2)); // [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```


<a name="l-8"></a>
## "Js First-Class" 
<p>Functions in JS are "first-class" objects, this means that something has a value:</p>
```javascript runnable
let something = "Leo";
```

<a name="l-9"></a>
## "First-Class-functions" FcF 

> In JS, functions are First-Class and Higher-Order functions

### "JS First-Class" (FC)
<p>Functions in JS are "first-class" objects, this means that something has a value:</p>
```javascript runnable
let something = "FP";
console.log(something); // FP
```

<p>
Functions in JavaScript are treated as objects, not just methods: mean that you can STORE functions into a 'variable':
</p>
```javascript runnable
let subName = function(a,b) { return a + b }; 
console.log(subName); // ƒ(a,b){ return a + b }
```

<a name="l-10"></a>
## **"Higher-order-functions"** (HoF)

> Functions are objects: not just methods: mean that you can STORE functions into a variable, they can be passed around as data, can appear as parameters to other functions  (these are usually known as callbacks), and can be returned from other functions (which leads to things like Composable Functions)



```javascript runnable
// yes we can create functions as many other languages
function foo(n){ return n + 1}

// BUT JS also allow us to create an anonimous function AND assign it to a variable 
let HoF = function(n){ return n + 1};

// and then pass the function as a variable and execute it, or not
let HoF2 = HoF;
console.log(HoF(2)); // 3
```

```javascript runnable
// passing f() as arguments

function add(x, y) {
  return x + y
}
function subtract(x, y) {
  return x - y
}
function callFuncWith2Arguments(arg1, arg2, func) {
  return func(arg1, arg2)
}

callFuncWith2Arguments(1, 2, add); // 3
callFuncWith2Arguments(3, 1, subtract); // 2
```

> This allow us to have _Function Composition_: The fact that we can take a function and put into another function, 
allow us to _compose_ a lot of small functions into bigger functions.




