# FP Definition

> "Functional programming is a 'declarative' 'paradigm' of building software by 'composing pure functions', avoiding 'shared state', 'mutable data' and 'side-effects'. Placing the mayor emphasis on the use of functions; the goal, rather, is to 'abstract control flows and operations on data with these  functions and threaten them as building blocks' by relying on 'JS first-class'  and 'higher-order functions' to improve the modularity, predictability and reusability of your code.


## SO, FP essencially boils down to:
- Program everyting with functions (a "function flow" takes an input and gives an output)
- Avoid shared mutable state & side effects (use pure functions, a print it is not pure, because we don't have an output)
- FP is about pulling programs apart and reassembling them from the same parts, abstracted behind function boundaries.


## "declarative"
<p>FP is a declarative paradigm software development style, like IP or OOP, thats keeps 'functions' and 'data' separate
</p>

## "paradigm"
<p>In simple terms, it is a way of thinking about software construction, based on some development style that follow principles.
</p>


## "composing functions: Compose and Pipe"
<p>
Composition means that we attach multiple functions together, in a pipe, where the return value
of the first function becomes the input for the next function:

Function composition is the process of combining two or more functions in order to produce a new function.
Simply put, a composition of functions `f` . `g` (the dot means "composed with") can be defined as `f(g(x))`
(evaluates inside out, right to left = x, g and f) 

If you want to compose two functions you are forced to write your own compose function or use the already 
available ones in libraries such as Lodash and Ramda, also R provides pipe and composition.
</p>

```javascript
// using compose on TS
function f() {
    console.log("f(): evaluated");
    return function (target, propertyKey: string, descriptor: PropertyDescriptor) {
        console.log("f(): called");
    }
}
function g() {
    console.log("g(): evaluated");
    return function (target, propertyKey: string, descriptor: PropertyDescriptor) {
        console.log("g(): called");
    }
}
function h() { 
    console.log("h(): evaluated");
    return function (target, propertyKey: string, descriptor: PropertyDescriptor) {
        console.log("h(): called");
    }
}
class C { // some as: f(g(h()))
    @h()
    @f()
    @g()
}
// h(): evaluated
// f(): evaluated
// g(): evaluated
// g(): called
// f(): called
// h(): called
```

## "shared state" 

<p>
FP avoids shared state,â€Šinstead relying on immutable data structures and pure calculations.
Shared state is any variable, object, or memory space that exists in a shared scope, or as the property of an object being passed between scopes. 
</p>

Problems:
- The problem with shared state is that in order to understand the effects of a function,
 you have to know the entire history of every shared variable that the function uses or affects.
- A common bug associated to 'share state'is 'race-condition'
- Changing the order in which functions are called can cause a cascade of failures
 because functions which act on shared state are timing dependent.












asdasdasd?:
@[Get the even numbers in an array]({ "stubs": ["pure/pure.js"], "command": "node pure/pure.js" })


Now time for some code:
@[Get the even numbers in an array]({ "stubs": ["pure/impure.js"], "command": "node pure/impure.js" })



```javascript
function add2 (x){
  return x + 2
}
```
?[Pure or Impure Game?]
-[x] Pure
-[ ] Impure



# TECHIO> annotate
# Usage

```bash
TECHIO> annotate --file <FILENAME> --position <LINE[:COLUMN]> [OPTIONS] <MESSAGE>
```

# Description
Annotate the client code editor with margin marker and an associated message.


# Options

`-f, --file <FILENAME>` FILENAME is used to select the code editor associated with the displayed annotation. If a client editor filename is contained in the command filename, this editor is selected. If the FILENAME does not match with a client editor filename, the annotation is not displayed.


`-p, --position <LINE[:COLUMN]>` LINE represents the line of the marker. A COLUMN value can be appended to give more details about the precise position of the annotation. LINE and COLUMN are integer values.


`-t, --type <TYPE>` TYPE of the annotation. Valid values include: info, warning, and error. The default value is error.


`-c, --channel <CHANNEL>` The annotation information can also be optionally printed on a CHANNEL.

# Examples
Display a warning annotation on the line 3 of a main.js editor file with the associated message: warn: ';' not found.

```bash
TECHIO> annotate --type "warning" --file "a.js" --position 3 warn: ';' not found
```

Display an error annotation on the line 4 of a Main.java editor file with the following message: error: ';' expected at end of line. It also prints the message on a compilation channel with the name of the file, the line number, and the column.

```bash
TECHIO> annotate --channel "compilation" --file "Main.java" --position 4:8 error: ';' expected at end of line
```
