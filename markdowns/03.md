# FP Definition

> "Functional programming is a [**'declarative'**](#l-1) [**'paradigm'**](#l-2) of building software by **'composing pure functions'**, avoiding **'shared mutable state'**, **'mutable data'** and **'side-effects'**. Placing the mayor emphasis on the use of functions; **'abstracting control flows and operations on data with these functions and threaten them as building blocks'** by relying on **'JS first-class'**  and **'higher-order functions'** to improve the modularity, **predictability** and reusability of your code.

## So, FP essencially boils down to:
- Program everyting with functions (a "function flow" takes an input and gives an output)
- Avoid shared mutable state & side-effects (use pure functions)
- FP is about pulling programs apart and reassembling them from the same parts, abstracted behind function boundaries.

<a name="l-1"></a>
## **"declarative"**
<p>FP is a declarative paradigm software development style, like IP or OOP, thats keeps 'functions' and 'data' separate
</p>

<a name="l-1"></a>
## **"paradigm"**
<p>In simple terms, it is a way of thinking about software construction, based on some development style that follow principles.
</p>


## **"composing pure functions"**
<p>
Composition means that we attach multiple functions together, in a pipe, where the return value
of the first function becomes the input for the next function:

Function composition is the process of combining two or more functions in order to produce a new function.
Simply put, a composition of functions `f` . `g` (the dot means "composed with") can be defined as `f(g(x))`
(evaluates inside out, right to left = x, g and f) 

If you want to compose two functions you are forced to write your own compose function or use the already 
available ones in libraries such as Lodash and Ramda, also R provides pipe and composition.
</p>

### Function Composition 
#### Compose and Pipe:
<p>
Composition f(g(x)) and Pipe are function composition, what is change is the order:
Composition: inside out, Pipe: outside in.
</p>

```javascript
// using compose on TS
function f() {
    console.log("f(): evaluated");
    return function (target, propertyKey: string, descriptor: PropertyDescriptor) {
        console.log("f(): called");
    }
}
function g() {
    console.log("g(): evaluated");
    return function (target, propertyKey: string, descriptor: PropertyDescriptor) {
        console.log("g(): called");
    }
}
function h() { 
    console.log("h(): evaluated");
    return function (target, propertyKey: string, descriptor: PropertyDescriptor) {
        console.log("h(): called");
    }
}
class C { // some as: f(g(h()))
    @h()
    @f()
    @g()
}
// h(): evaluated
// f(): evaluated
// g(): evaluated
// g(): called
// f(): called
// h(): called
```

## "shared mutable state" 

<p>
FP avoids shared state, instead relying on immutable data structures and pure calculations.
Shared state is any variable, object, or memory space that exists in a shared scope, or as the property of an object being passed between scopes. 
</p>

### Problems:
- The problem with shared state is that in order to understand the effects of a function,
 you have to know the entire history of every shared variable that the function uses or affects.
- A common bug associated to 'share state'is 'race-condition'
- Changing the order in which functions are called can cause a cascade of failures
 because functions which act on shared state are timing dependent.

## With shared state, the order in which function calls are made changes the result of the function calls
@[Order 1]({ "stubs": ["pure/order1.js"], "command": "node pure/order1.js" })
@[Order 2]({ "stubs": ["pure/order2.js"], "command": "node pure/order2.js" })
@[Better Do]({ "stubs": ["pure/betterOrder.js"], "command": "node pure/betterOrder.js" })

## "mutable data" 
<p>An mutable object is any object which can be modified after it's created.</p>

### "immutable"
<p>
An immutable value or object cannot be changed, so every update creates new value, leaving the old one untouched.

For example, if your application state is immutable, you can save all the states objects in a single store to
 easily implement undo/redo functionality
</p>

### "pure function" 
A pure function is a function which:
- Given the same input, always return the same output
- Has no side-effects (immutable)


```javascript runnable
// pure
function add2 (x){
  return x + 2
}
```
```javascript runnable
// not pure
// impure: because it reads/modifies an external variable, counter, which isn’t local to the function’s scope.
const y = 2
function adder (x){
  return x + y
}
```

## "side-effects" 

Mutating data can cause unintended side-effects.

> A side effect is a change of system state or observable interaction with the outside world that occurs during the calculation of a result.

Side effects may include, but are not limited to
-Anything that rely on current time, it is impure.
-Anything that rely on random number
-Changing the file system
-Inserting a record into a database
-Making an http call
-Querying the DOM
-Accessing system state
-I/O interaction (user intput, disk access, network access, printing to the screen) is impure throws



## 
![Minimizing moving parts](https://raw.githubusercontent.com/leolanese/FP/master/M-feathers.PNG)


## "Js First-Class" 
<p>Functions in JS are "first-class" objects, this means that something has a value:</p>
```javascript runnable
let something = "Leo";
```


## "First-Class-functions" FcF 
<p>Functions in JavaScript are treated as objects, not just methods: mean that you can STORE functions into a variable:</p>
```javascript runnable
var subName = function(a,b) { return name + a + b }; 
```

## "Higher-order-functions" HoF
<p>A higher-order function is a function that can take another function as an argument, 
or that returns a function as a result. In JS functions are Higher-Order and First-Class functions</p>

```javascript runnable
// yes we can create functions as many other languages
function foo(n){ return n + 1}

// BUT JS also allow us to create an anonimous function AND assign it to a variable
let HoF = function(n){ return n + 1};

// and then pass the function as a variable
var HoF2 = HoF;
HoF(2); // 3 :)
```

## "Abstraction"
<p>
In the context of programming, these kinds of vocabularies are usually
called 'abstractions'. Abstractions hide details and give us the ability to
talk about problems at a higher (or more abstract) level.</p>

```javascript  runnable
// calculate squares IP
const array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

// a way
let arraySquares = [];
for(let i = 0; i < array.length; i++) {
    arraySquares[i] = Math.pow(array[i], 2);
}
console.log(arraySquares); // [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

// better calculate squares FP
array.map(x => Math.pow(x, 2)); // [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```




